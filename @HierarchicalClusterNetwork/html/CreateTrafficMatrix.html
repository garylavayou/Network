
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>CreateTrafficMatrix</title><meta name="generator" content="MATLAB 8.6"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2016-06-02"><meta name="DC.source" content="CreateTrafficMatrix.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>CreateTrafficMatrix</h1><!--introduction--><p>randomly generate inter-domain flows between cluster nodes and core nodes, and intra-domain flows between nodes in one cluster.</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Method Declaration</a></li><li><a href="#3">generate inter-domain traffic</a></li><li><a href="#7">generate intra-domain traffic</a></li></ul></div><h2>Method Declaration<a name="1"></a></h2><pre class="language-matlab">flow_table = CreateTrafficMatrix(this, seed, inter_density, b_intra, intra_density)
</pre><p><tt>inter_density</tt>: controls the number of inter-flow originated from each node. this     argument can be a scalar or an (1*2) vector or an (n*2) matrix to denote the     uplink/downlink traffic density, where n is the number of domains to the core.</p><p><tt>b_intra</tt>: true, intra-domain flow is enabled.</p><p><tt>intra_density</tt>: controls the number of intra-flow originated from each node. this     argument can be a scalar or an (n*1) vector to denote each cluster's traffic     density.</p><div><ul><li>If flow_density(inter/intra) &lt; 1, the number of flows is proportional to the         number of nodes;</li><li>Otherwise, flow_density is the number of flows originated from each node.</li></ul></div><p>NOTE: this function should be called after the graph has been created.</p><h2>generate inter-domain traffic<a name="3"></a></h2><h2>generate intra-domain traffic<a name="7"></a></h2><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2015b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% CreateTrafficMatrix
% randomly generate inter-domain flows between cluster nodes and core nodes, 
% and intra-domain flows between nodes in one cluster.
%% Method Declaration
%   flow_table = CreateTrafficMatrix(this, seed, inter_density, b_intra, intra_density)
%
% |inter_density|: controls the number of inter-flow originated from each node. this
%     argument can be a scalar or an (1*2) vector or an (n*2) matrix to denote the
%     uplink/downlink traffic density, where n is the number of domains to the core.  
%
% |b_intra|: true, intra-domain flow is enabled.
%
% |intra_density|: controls the number of intra-flow originated from each node. this
%     argument can be a scalar or an (n*1) vector to denote each cluster's traffic
%     density. 
%
% * If flow_density(inter/intra) < 1, the number of flows is proportional to the
%         number of nodes; 
% * Otherwise, flow_density is the number of flows originated from each node.
%
% NOTE: this function should be called after the graph has been created.
function flow_table = CreateTrafficMatrix(this, seed, inter_density, b_intra, intra_density)


up_demand_max = 10;            % tunable parameter
up_demand_min = 1;
up_down_ratio = 3;
down_demand_max = up_down_ratio*up_demand_max;
down_demand_min = up_down_ratio*up_demand_min;
intra_demand_max = 10;
intra_demand_min = 1;
intra_demand_max0 = 50;
intra_demand_min0 = 5;

graph = this.graph;
flow_table = zeros(graph.Size*graph.Size,4);
flow_table(:,4) = (1:graph.Size*graph.Size)';

rng(seed);
K = 0;
%% generate inter-domain traffic
if nargin == 2
	inter_density = ones(this.ClusterNumber, 2)*(-1);
else
	if numel(inter_density) == 1
		inter_density = repmat(inter_density, this.ClusterNumber-1, 2);
	elseif size(inter_density,1)==1 && size(inter_density,2)==2
		inter_density = repmat(inter_density, this.ClusterNumber-1, 1);
	elseif size(inter_density,1)==2 && size(inter_density,2)==1
		inter_density = repmat(inter_density', this.ClusterNumber-1, 1);
	end
end
core_size = this.ClusterSize(1);
for i = 2:this.ClusterNumber
    di = i-1;       % since only (this.ClusterNumber-1) backhaul clusters
	for j = 1:this.ClusterSize(i)
		node_id = sum(this.ClusterSize(1:i-1))+j;		% level 2 cluster node id
		% downlink
		if inter_density(di,1) == -1
			core_peer = unique(randi(core_size,core_size,1)); 
			% core_peer is different from node_id;
			num_core_peer = length(core_peer);
		elseif inter_density(di,1) == 0
			continue;
		else
			if inter_density(di,1) < 1
				num_core_peer = ceil(core_size*inter_density(di,1));
			else
				num_core_peer = min(inter_density(di,1), core_size);
			end
			% core_peer is different from node_id;
			core_peer = unique_randi(core_size, num_core_peer);
		end
		flow_table(K+1:K+num_core_peer,1)=core_peer;
		flow_table(K+1:K+num_core_peer,2)=node_id;
		flow_table(K+1:K+num_core_peer,3)=...
            round(unifrnd(down_demand_min,down_demand_max,num_core_peer,1));
		K = K+num_core_peer;
		%% uplink
		if inter_density(di,2) == -1
			core_peer = unique(randi(core_size,core_size,1)); 
			% core_peer is different from node_id;
			num_core_peer = length(core_peer);
		elseif inter_density(di,2) == 0
			continue;
		else
			if inter_density(di,2) < 1
				num_core_peer = ceil(core_size*inter_density(di,2));
			else
				num_core_peer = min(inter_density(di,2), core_size);
			end
			% core_peer is different from node_id;
			core_peer = unique_randi(core_size, num_core_peer);
		end
		flow_table(K+1:K+num_core_peer,1)=node_id;
		flow_table(K+1:K+num_core_peer,2)=core_peer;
		flow_table(K+1:K+num_core_peer,3)=...
            round(unifrnd(up_demand_min,up_demand_max,num_core_peer,1));
		K = K+num_core_peer;
	end
end
%% generate intra-domain traffic
if nargin <= 3
	flow_table = flow_table(1:K,:);
	return;
end
if b_intra == false
	flow_table = flow_table(1:K,:);
	return;
end
if nargin == 4
	intra_density = zeros(this.ClusterNumber, 1); 
elseif numel(intra_density) == 1
	intra_density = repmat(intra_density, this.ClusterNumber, 1);
end
% core intra-domain traffic
% dest_offset = 0;
for i = 1:this.ClusterNumber
	for j = 1:this.ClusterSize(i)
		node_id = sum(this.ClusterSize(1:i-1))+j;
		if intra_density(i) == -1
			dest = sum(this.ClusterSize(1:i-1)) + unique(randi(this.ClusterSize(i),this.ClusterSize(i),1)); 
			dest(dest==node_id)=[];    % exclude the same src and dest.
			ld = length(dest);
		elseif intra_density(i) == 0
			continue;
		else
			if intra_density(i) < 1
				nd = ceil(this.ClusterSize(i)*intra_density(i))+1;
			else
				nd = min(intra_density(i), this.ClusterSize(i))+1;
			end
			% core_peer is different from node_id;
			dest = unique_randi(this.ClusterSize(i), nd);
			dest(dest==node_id)=[];    % exclude the same src and dest.
			ld =length(dest);
			if ld == nd
				dest(randi(ld,1)) = [];
				ld = ld - 1;
			end
		end
		flow_table(K+1:K+ld,1)=node_id;
		flow_table(K+1:K+ld,2)=dest;
		if i == 1
			flow_table(K+1:K+ld,3)=round(unifrnd(intra_demand_min0,intra_demand_max0,ld,1));
		else
			flow_table(K+1:K+ld,3)=round(unifrnd(intra_demand_min,intra_demand_max,ld,1));
		end
		K = K+ld;		
	end
% dest_offset = dest_offset + this.ClusterSize(i);
end
	
flow_table = flow_table(1:K,:);
end
##### SOURCE END #####
--></body></html>