
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>MFODA-TE LP relaxation method for MFODA-TE problem</title><meta name="generator" content="MATLAB 8.6"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2016-06-06"><meta name="DC.source" content="MFODA_TE.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>MFODA-TE LP relaxation method for MFODA-TE problem</h1><!--introduction--><p>LP relaxation method</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Function declaration</a></li><li><a href="#3">Initialization</a></li><li><a href="#4">Linear programing</a></li><li><a href="#5">Rounding the Linear Program solution</a></li><li><a href="#6">Flow selection method</a></li><li><a href="#7">The path selection method</a></li></ul></div><h2>Function declaration<a name="1"></a></h2><pre class="language-matlab"><span class="keyword">function</span> [theta, a] = MFODA_TE( this, flow_table_index, w )
</pre><h2>Initialization<a name="3"></a></h2><h2>Linear programing<a name="4"></a></h2><p>Find path-flow variables by i-FPTAS with graph and flow_list.</p><h2>Rounding the Linear Program solution<a name="5"></a></h2><p>Find a feasible solution for the MFODA-TE problem.</p><h2>Flow selection method<a name="6"></a></h2><p>Each time, we select one BS in a (weighted) round robin method, and then we select one unassociated flow <img src="MFODA_TE_eq15636846968047188835.png" alt="$k$"> from the selected BS. * If the weighted round robin method is used, the weight of a BS <img src="MFODA_TE_eq05671228016298599287.png" alt="$i$"> can be calculated according to its aggregated demand, take downlink as an example: <img src="MFODA_TE_eq14787440681581249347.png" alt="$w(i)=\sum_{k:t(k)=i}{d(k)}$">.</p><p>Each time we select an unassociated flow respectively for uplink and downlink.</p><h2>The path selection method<a name="7"></a></h2><p>The path selection for flow is vital to guarantee the quality of the rounding process. Our method considers using all paths from the flow's source to a common D-GW to serves the flow. We select the set of paths that has largest aggregated bandwidth to serve the flow. At the same time the serving D-GW is also determined. * If the aggregated bandwidth is not enough to serve the flow, the path-flow variables are increased with a factor, such that the flow demand is meeted, unde the condition that the link capacity constraint is not violated. * If the link capacity constraint cannot meet, this flow cannot be admit (actually we can try the set of flows with second large aggregate bandwidth). And a feasible solution of the original problem cannot be found. * We can use a linear program to find how to increase the bandwidth of the paths that will serve the flow. The problem can be formulated as</p><p><img src="MFODA_TE_eq13380753766378006339.png" alt="$$&#xA;\begin{array}{rl}&#xA;\min &amp;~ \theta \\&#xA;{\rm s.t.} &amp;\sum\limits_{p\in\mathcal{P}_e}{y(p)}\le\theta c(e), \forall e\in\mathcal{L},\\&#xA;&amp;\sum\limits_{p\in\mathcal{P}_k}{y(p)\ge d(k)},\\&#xA;&amp;y(p)\ge 0, ~\forall p\in\mathcal{P},\\&#xA;&amp; 0\le\theta\le 1,&#xA;\end{array}&#xA;$$"></p><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2015b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% MFODA-TE LP relaxation method for MFODA-TE problem
% LP relaxation method

%% Function declaration
%   function [theta, a] = MFODA_TE( this, flow_table_index, w )
function [theta, a] = MFODA_TE( this, traffic_matrix_index, w )
 
%% Initialization
graph = this.graph;
flow_list = this.TrafficProfiles{traffic_matrix_index};
K = size(flow_list,1);
L = length(graph.Capacity);
BS_index = this.UpperSize + (1:this.BottomSize);
core_index = 1:this.UpperSize;
DGW_identifier = (find(sum(graph.Adjacent(core_index, BS_index),2)))';
n_BS = length(BS_index);
MAX_DGW = DGW_identifier(end);

%%% Linear programing
% Find path-flow variables by i-FPTAS with graph and flow_list.
[lambda, path_set] = this.MaxConcurrentFlowPath(w, traffic_matrix_index);
path_set.MultiplyBandwidth(1/lambda(2));

%% Rounding the Linear Program solution
% Find a feasible solution for the MFODA-TE problem.
b_processd_flow = zeros(K, 1);
residual_capacity = graph.Capacity;
a = zeros(this.UpperSize, K);
flow_group_d = cell(n_BS,1);
flow_group_u = cell(n_BS,1);
for j=1:n_BS
    BS_j = BS_index(j);
    flow_group_d{j} = find(flow_list(:,2)==BS_j);
    flow_group_u{j} = find(flow_list(:,1)==BS_j);
end
visited_index_d = ones(n_BS,1);
visited_index_u = ones(n_BS,1);
while ~isempty(find(b_processd_flow == 0,1))
    for j = 1:n_BS
%         BS_j = BS_index(j);
        for s = 1:2
            %% Flow selection method
            % Each time, we select one BS in a (weighted) round robin method, and then we
            % select one unassociated flow $k$ from the selected BS.
            % * If the weighted round robin method is used, the weight of a BS $i$ can be
            % calculated according to its aggregated demand, take downlink as an example:
            % $w(i)=\sum_{k:t(k)=i}{d(k)}$.
            %
            % Each time we select an unassociated flow respectively for uplink and
            % downlink.
            k = [];
            if s==1 && visited_index_d(j) <= length(flow_group_d)
                % find an unprocessed downlink flow
                k = flow_group_d{j}(visited_index_d(j));
                visited_index_d(j) = visited_index_d(j) + 1;
            end
            if s==2 && visited_index_u(j) <= length(flow_group_u)
                % find an unprocessed uplink flow
                k = flow_group_u{j}(visited_index_u(j));
                visited_index_u(j) = visited_index_u(j) + 1;
            end
            %% The path selection method
            % The path selection for flow is vital to guarantee the quality of the
            % rounding process. Our method considers using all paths from the flow's
            % source to a common D-GW to serves the flow. We select the set of paths that
            % has largest aggregated bandwidth to serve the flow. At the same time the
            % serving D-GW is also determined. 
            % * If the aggregated bandwidth is not enough to serve the flow, the path-flow
            % variables are increased with a factor, such that the flow demand is meeted,
            % unde the condition that the link capacity constraint is not violated.
            % * If the link capacity constraint cannot meet, this flow cannot be admit
            % (actually we can try the set of flows with second large aggregate
            % bandwidth). And a feasible solution of the original problem cannot be found.
            % * We can use a linear program to find how to increase the bandwidth of the
            % paths that will serve the flow. The problem can be formulated as
            %
            % $$
            % \begin{array}{rl}
            % \min &~ \theta \\
            % {\rm s.t.} &\sum\limits_{p\in\mathcal{P}_e}{y(p)}\le\theta c(e), \forall e\in\mathcal{L},\\
            % &\sum\limits_{p\in\mathcal{P}_k}{y(p)\ge d(k)},\\
            % &y(p)\ge 0, ~\forall p\in\mathcal{P},\\
            % & 0\le\theta\le 1,
            % \end{array}
            % $$
            %
            if ~isempty(k)
                % DGW_traffic(DGW_i) is the total traffic of flow k that passes through
                %     DGW_i.  
                DGW_traffic = zeros(this.UpperSize,1);
                % DGW_path_set(DGW_i) is the path set that serves flow i and passes
                %     through DGW_i
                DGW_path_index_set = cell(this.UpperSize,1);
                src = flow_list(k,1);
                dest = flow_list(k,2);
                num_path = length(path_set.Element{src,dest});
                for path_index = 1:num_path
                    node_list = path_set.Element{src,dest}(path_index).node_list;
                    % we find the D-GW that is closet to the BS.
                    %   since the serving D-GW is the first core node on the path, we can
                    %       perform the following operation to find the serving D-GW.
                    if s == 1
                        i = find(node_list<=MAX_DGW,1,'last');
                    else
                        i = find(node_list<=MAX_DGW,1);
                    end
                    DGW_i = node_list(i);
                    DGW_traffic(DGW_i) = DGW_traffic(DGW_i) + ...
                        path_set.Element{src,dest}(path_index).bandwidth;
                    % store the index of paths that pass through DGW_i;
                    DGW_path_index_set{DGW_i} = [DGW_path_index_set{DGW_i} path_index];
                end
                if num_path ~= 1
                    [~, ix] = sort(DGW_traffic, 'descend');
                else
                    ix = DGW_i;
                end
                b_admit = 0;
                for i = ix'
                    if DGW_traffic(i) == 0
                        break;
                    end
                    alpha = flow_list(k,3)/DGW_traffic(i);
                    fe = zeros(L,1);    % count the flow amount of flow k on each edge.
                    for path_index=DGW_path_index_set{i}
                        node_list = path_set.Element{src,dest}(path_index).node_list;
                        for r = 1:(length(node_list)-1)
                            ei = graph.Inverse(node_list(r),node_list(r+1));
                            fe(ei) = fe(ei) + path_set.Element{src,dest}(path_index).bandwidth;
                        end
                    end
                    if isempty(find(residual_capacity < alpha*fe, 1))
                        a(i,k) = 1;
                        if num_path ~= 1
                            for path_index=DGW_path_index_set{i}
                                path_set.Element{src,dest}(path_index).MultiplyBandwidth(alpha);
                            end
                        end
                        residual_capacity = residual_capacity - fe*alpha;
                        b_admit = 1;
                        break;
                    else
                        for path_index=DGW_path_index_set{i}
                            path_set.Element{src,dest}(path_index).bandwidth = 0;
                        end
                    end
                end
                if b_admit == 0
                    warning('a flow %d(%d,%d) cannot be admmited.',...
                        k, src, dest);
                end
                b_processd_flow(k) = 1;
            end
        end
    end
end
theta = max((graph.Capacity-residual_capacity)./graph.Capacity);
end


##### SOURCE END #####
--></body></html>